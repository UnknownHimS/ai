<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sci-Fi AI Chatbot</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron&display=swap" rel="stylesheet" />
  <style>
    body {
      background: radial-gradient(circle at center, #000 30%, #111 100%);
      color: #0ff;
      font-family: 'Orbitron', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      flex-direction: column;
      overflow: hidden;
    }
    #chat {
      width: 90%;
      max-width: 700px;
      height: 70vh;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #0ff;
      padding: 10px;
      overflow-y: auto;
      margin-bottom: 10px;
      box-shadow: 0 0 20px #0ff;
      border-radius: 10px;
    }
    #chat p {
      margin: 5px 0;
    }
    .user {
      color: #0f0;
    }
    .bot {
      color: #f0f;
    }
    #inputArea {
      width: 90%;
      max-width: 700px;
      display: flex;
    }
    #inputArea input {
      flex: 1;
      padding: 10px;
      border: none;
      background: #222;
      color: #0ff;
      font-family: 'Orbitron', sans-serif;
    }
    #inputArea button {
      background: #0ff;
      color: #000;
      border: none;
      padding: 10px 20px;
      cursor: pointer;
      font-family: 'Orbitron', sans-serif;
    }
    #inputArea button:hover {
      background: #0cc;
    }
  </style>
</head>
<body>
 <h1>Please use proper spelling; this chatbot is still learning.</h1>

  <div id="chat"></div>
  <div id="inputArea">
    <input type="text" id="userInput" placeholder="Type a message..." />
    <button onclick="sendMessage()">Send</button>
  </div>

  <script>
    const chat = document.getElementById('chat');
    const input = document.getElementById('userInput');

    const dataFiles = {
      bible: "https://raw.githubusercontent.com/UnknownHimS/ai/main/bible.json"
    };

    let loadedData = {};
    let currentContext = null;

    function appendMessage(sender, text) {
      const p = document.createElement('p');
      p.className = sender;
      p.textContent = (sender === 'user' ? 'ðŸ§‘ You: ' : 'ðŸ¤– ShabbyBot: ') + text;
      chat.appendChild(p);
      chat.scrollTop = chat.scrollHeight;
    }

    async function loadData(category) {
      if (!loadedData[category]) {
        try {
          const response = await fetch(dataFiles[category]);
          if (response.ok) {
            const json = await response.json();
            loadedData[category] = json;
          } else {
            loadedData[category] = [];
          }
        } catch {
          loadedData[category] = [];
        }
      }
      return loadedData[category];
    }

    function matchKeywords(keywords, text) {
      const lowerText = text.toLowerCase();
      return keywords.every(kw => lowerText.includes(kw.toLowerCase()));
    }

    async function fetchWikipediaSummary(topic) {
      const encodedTopic = encodeURIComponent(topic.toLowerCase());
      const url = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodedTopic}`;
      try {
        const res = await fetch(url);
        if (!res.ok) return null;
        const data = await res.json();
        return data.extract || "No summary available.";
      } catch {
        return "Failed to fetch Wikipedia content.";
      }
    }

    function extractSmartTopic(input) {
      const original = input.trim().toLowerCase().replace(/[?.,!]/g, '');
      const stopwords = ['what', 'is', 'are', 'was', 'were', 'who', 'do', 'does', 'did', 'explain', 'define', 'about', 'tell', 'me', 'the', 'a', 'an', 'of', 'it', 'that', 'on', 'in', 'to', 'from', 'by'];

      // Direct pattern: "ChatGPT, what is it"
      if (original.includes(', what is it')) {
        return original.split(',')[0].trim();
      }

      // Common pattern: "What is gravity"
      if (original.startsWith('what is') || original.startsWith('who is') || original.startsWith('define') || original.startsWith('explain') || original.startsWith('what are')) {
        const parts = original.split(' ');
        const filtered = parts.slice(2).filter(word => !stopwords.includes(word));
        return filtered.join(' ');
      }

      // Pattern: "what about mars"
      if (original.startsWith('what about')) {
        return original.replace('what about', '').trim();
      }

      // Pattern: "what the ball doing"
      if (original.startsWith('what the')) {
        const words = original.split(' ');
        if (words.length > 2) return words[2];
      }

      // Pattern: "Tell me about XYZ"
      if (original.startsWith('tell me about')) {
        return original.replace('tell me about', '').trim();
      }

      // Fallback: remove stopwords and take meaningful words
      const cleaned = original.split(' ').filter(word => !stopwords.includes(word));
      return cleaned.slice(0, 4).join(' ');
    }

    async function getResponse(text) {
      text = text.toLowerCase();

      // 1. Handle context replies
      if (currentContext) {
        for (const category in loadedData) {
          const data = loadedData[category];
          for (const entry of data) {
            if (entry.required_context === currentContext && entry.keywords) {
              if (entry.keywords.includes(text)) {
                currentContext = null;
                return entry.output;
              }
            }
          }
        }
        return "I was waiting for a 'yes' or 'no' answer.";
      }

      // 2. Load all data categories
      const categoriesToLoad = Object.keys(dataFiles);
      await Promise.all(categoriesToLoad.map(cat => loadData(cat)));

      // 3. Try matching JSON keyword rules
      for (const category of categoriesToLoad) {
        const data = loadedData[category];
        for (const entry of data) {
          if (entry.__comment) continue;
          if (entry.keywords && matchKeywords(entry.keywords, text)) {
            if (entry.expecting) currentContext = entry.id;

            if (entry.output.startsWith("wiki:")) {
              const wikiTopic = entry.output.replace("wiki:", "").trim();
              const wikiResponse = await fetchWikipediaSummary(wikiTopic);
              return wikiResponse;
            }

            return entry.output;
          }
        }
      }

      // 4. If no JSON match, try extracting topic and fetch Wikipedia
      const topic = extractSmartTopic(text);
      if (topic) {
        const wikiResponse = await fetchWikipediaSummary(topic);
        return wikiResponse || "I couldn't find info on that.";
      }

      return "Sorry, I didn't get that.";
    }

    async function sendMessage() {
      const text = input.value.trim();
      if (!text) return;
      appendMessage('user', text);
      input.value = '';
      const botReply = await getResponse(text);
      appendMessage('bot', botReply);
    }

    input.addEventListener('keydown', e => {
      if (e.key === 'Enter') sendMessage();
    });
  </script>

</body>
</html>
