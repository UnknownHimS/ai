<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bible AI</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 2rem;
      max-width: 700px;
    }
    label, select, input, button {
      display: block;
      margin: 0.5rem 0;
      font-size: 1rem;
      width: 100%;
      max-width: 400px;
    }
    #result {
      margin-top: 1rem;
      border: 1px solid #ccc;
      padding: 1rem;
      background: #f9f9f9;
      max-height: 400px;
      overflow-y: auto;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <h1>Bible AI</h1>

  <label for="translation">Select Translation:</label>
  <select id="translation"></select>

  <label for="query">Enter verse or chapter (e.g., John 3:16 or Genesis 1):</label>
  <input type="text" id="query" placeholder="Book Chapter:Verse or Book Chapter" />

  <button id="searchBtn">Search</button>

  <div id="result"></div>

<script>
  const translationSelect = document.getElementById('translation');
  const queryInput = document.getElementById('query');
  const searchBtn = document.getElementById('searchBtn');
  const resultDiv = document.getElementById('result');

  const apiBase = 'https://bible.helloao.org/api';

  // Load available translations into dropdown
  async function loadTranslations() {
    try {
      const res = await fetch(`${apiBase}/available_translations.json`);
      if (!res.ok) throw new Error('Failed to load translations');
      const data = await res.json();
      // data is object with keys as translation codes
      for (const [code, info] of Object.entries(data)) {
        const opt = document.createElement('option');
        opt.value = code;
        opt.textContent = `${info.name} (${code.toUpperCase()})`;
        translationSelect.appendChild(opt);
      }
      // default select first
      if (translationSelect.options.length > 0) {
        translationSelect.selectedIndex = 0;
      }
    } catch (err) {
      resultDiv.textContent = 'Error loading translations: ' + err.message;
    }
  }

  // Normalize book name to short_name used by API
  async function getBooksMap(translation) {
    const res = await fetch(`${apiBase}/${translation}/books.json`);
    if (!res.ok) throw new Error('Failed to load books');
    const books = await res.json(); // array of {name, short_name, chapters}
    // create map: name lowercased to short_name
    const map = {};
    books.forEach(book => {
      map[book.name.toLowerCase()] = book.short_name.toLowerCase();
    });
    return map;
  }

  // Parse user input, return {book, chapter, verse} or null if invalid
  function parseQuery(input) {
    // Examples to handle:
    // "John 3:16"
    // "Genesis 1"
    // "1 Corinthians 13:4"

    input = input.trim();

    // Match something like "BookName Chapter:Verse" or "BookName Chapter"
    // The book name can be multiple words including numbers

    const regex = /^(.+?)\s+(\d+)(?::(\d+))?$/;
    const match = input.match(regex);
    if (!match) return null;

    return {
      bookName: match[1].toLowerCase(),
      chapter: parseInt(match[2], 10),
      verse: match[3] ? parseInt(match[3], 10) : null
    };
  }

  // Fetch chapter data and display requested verse or whole chapter
  async function fetchAndDisplay(translation, bookShort, chapter, verse = null) {
    try {
      resultDiv.textContent = 'Loading...';
      const res = await fetch(`${apiBase}/${translation}/${bookShort}/${chapter}.json`);
      if (!res.ok) throw new Error('Chapter not found');
      const data = await res.json();
      const verses = data.verses;

      if (verse !== null) {
        // Find specific verse
        const v = verses.find(v => v.verse === verse);
        if (v) {
          resultDiv.textContent = `${data.book} ${chapter}:${verse} - ${v.text}`;
        } else {
          resultDiv.textContent = `Verse ${verse} not found in ${data.book} chapter ${chapter}.`;
        }
      } else {
        // Display whole chapter
        let text = `${data.book} Chapter ${chapter}\n\n`;
        verses.forEach(v => {
          text += `${v.verse}. ${v.text}\n`;
        });
        resultDiv.textContent = text;
      }
    } catch (err) {
      resultDiv.textContent = 'Error fetching chapter: ' + err.message;
    }
  }

  async function onSearch() {
    const translation = translationSelect.value;
    const query = queryInput.value.trim();
    if (!query) {
      resultDiv.textContent = 'Please enter a verse or chapter.';
      return;
    }

    const parsed = parseQuery(query);
    if (!parsed) {
      resultDiv.textContent = 'Invalid input format. Use "Book Chapter:Verse" or "Book Chapter".';
      return;
    }

    try {
      // Get book short_name map
      const booksMap = await getBooksMap(translation);

      // Try exact match or fallback ignoring numbers in book name (like "1 corinthians" vs "1corinthians")
      let bookShort = booksMap[parsed.bookName];
      if (!bookShort) {
        // Try remove spaces in book name and search again
        const noSpace = parsed.bookName.replace(/\s/g, '');
        bookShort = booksMap[noSpace];
      }

      if (!bookShort) {
        resultDiv.textContent = `Book "${parsed.bookName}" not found in ${translation.toUpperCase()}.`;
        return;
      }

      await fetchAndDisplay(translation, bookShort, parsed.chapter, parsed.verse);
    } catch (err) {
      resultDiv.textContent = 'Error: ' + err.message;
    }
  }

  searchBtn.addEventListener('click', onSearch);
  queryInput.addEventListener('keydown', e => {
    if (e.key === 'Enter') {
      onSearch();
    }
  });

  // Load translations on page load
  loadTranslations();

</script>
</body>
</html>
