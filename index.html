<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sci-Fi AI Chatbot</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron&display=swap" rel="stylesheet" />
  <style>
    body {
      background: radial-gradient(circle at center, #000 30%, #111 100%);
      color: #0ff;
      font-family: 'Orbitron', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
      flex-direction: column;
      overflow: hidden;
    }
    #chat {
      width: 90%;
      max-width: 700px;
      height: 70vh;
      background: rgba(0, 0, 0, 0.8);
      border: 2px solid #0ff;
      padding: 10px;
      overflow-y: auto;
      margin-bottom: 10px;
      box-shadow: 0 0 20px #0ff;
      border-radius: 10px;
    }
    #chat p {
      margin: 5px 0;
    }
    .user {
      color: #0f0;
    }
    .bot {
      color: #f0f;
    }
    #inputArea {
      width: 90%;
      max-width: 700px;
      display: flex;
    }
    #inputArea input {
      flex: 1;
      padding: 10px;
      border: none;
      background: #222;
      color: #0ff;
      font-family: 'Orbitron', sans-serif;
    }
    #inputArea button {
      background: #0ff;
      color: #000;
      border: none;
      padding: 10px 20px;
      cursor: pointer;
      font-family: 'Orbitron', sans-serif;
    }
    #inputArea button:hover {
      background: #0cc;
    }
  </style>
</head>
<body>
  <h1>Please use proper spelling; this chatbot is still learning.</h1>

  <div id="chat"></div>
  <div id="inputArea">
    <input type="text" id="userInput" placeholder="Type a message..." />
    <button onclick="sendMessage()">Send</button>
  </div>

  <script>
    const chat = document.getElementById('chat');
    const input = document.getElementById('userInput');

    const dataFiles = {
      bible: "https://raw.githubusercontent.com/UnknownHimS/ai/main/bible.json"
    };

    let loadedData = {};
    let currentContext = null;
    let conversationHistory = [];

    // Enhanced AI intent detection patterns
    const intentPatterns = {
      when: {
        triggers: ['when', 'what time', 'what year', 'what date', 'how long ago'],
        contextual: ['occurred', 'happened', 'founded', 'established', 'created', 'born', 'died', 'started', 'ended'],
        negativeContext: ['how', 'why', 'where', 'who exactly']
      },
      who: {
        triggers: ['who', 'who is', 'who was', 'who were', 'which person', 'what person'],
        contextual: ['inventor', 'creator', 'founder', 'author', 'leader', 'president', 'king', 'emperor'],
        negativeContext: ['when', 'where', 'how', 'why']
      },
      where: {
        triggers: ['where', 'in which', 'what location', 'what place', 'what country', 'what city'],
        contextual: ['located', 'situated', 'found', 'based', 'originated', 'from'],
        negativeContext: ['when', 'who', 'how', 'why']
      },
      how: {
        triggers: ['how', 'how does', 'how did', 'in what way', 'by what means', 'what method'],
        contextual: ['work', 'function', 'operate', 'process', 'mechanism', 'procedure'],
        negativeContext: ['when', 'where', 'who exactly']
      },
      why: {
        triggers: ['why', 'why did', 'why does', 'what reason', 'what cause', 'for what purpose'],
        contextual: ['because', 'reason', 'purpose', 'cause', 'motivation'],
        negativeContext: ['when', 'where', 'who', 'how exactly']
      },
      definition: {
        triggers: ['what is', 'what are', 'what was', 'what were', 'define', 'explain', 'meaning of'],
        contextual: ['means', 'refers to', 'defined as', 'known as'],
        negativeContext: ['when exactly', 'where exactly', 'who exactly', 'how exactly', 'why exactly']
      },
      comparison: {
        triggers: ['difference between', 'compare', 'versus', 'vs', 'better than', 'similar to'],
        contextual: ['different', 'same', 'alike', 'contrast', 'comparison'],
        negativeContext: []
      }
    };

    // Sentiment and context analysis
    const sentimentWords = {
      positive: ['good', 'great', 'excellent', 'amazing', 'wonderful', 'fantastic', 'love', 'like'],
      negative: ['bad', 'terrible', 'awful', 'hate', 'dislike', 'horrible', 'wrong'],
      neutral: ['okay', 'fine', 'normal', 'average', 'standard']
    };

    function appendMessage(sender, text) {
      const p = document.createElement('p');
      p.className = sender;
      p.textContent = (sender === 'user' ? 'ðŸ§‘ You: ' : 'ðŸ¤– ShabbyBot: ') + text;
      chat.appendChild(p);
      chat.scrollTop = chat.scrollHeight;
      
      // Store conversation history for context
      conversationHistory.push({ sender, text, timestamp: Date.now() });
      if (conversationHistory.length > 10) conversationHistory.shift();
    }

    async function loadData(category) {
      if (!loadedData[category]) {
        try {
          const response = await fetch(dataFiles[category]);
          if (response.ok) {
            const json = await response.json();
            loadedData[category] = json;
          } else {
            loadedData[category] = [];
          }
        } catch {
          loadedData[category] = [];
        }
      }
      return loadedData[category];
    }

    function matchKeywords(keywords, text) {
      const lowerText = text.toLowerCase();
      return keywords.every(kw => lowerText.includes(kw.toLowerCase()));
    }

    // Enhanced intent detection with AI-like logic
    function detectIntent(input) {
      const text = input.toLowerCase();
      const words = text.split(/\s+/);
      const sentences = text.split(/[.!?]+/).filter(s => s.trim());
      
      let scores = {};
      
      // Initialize scores
      Object.keys(intentPatterns).forEach(intent => scores[intent] = 0);
      
      // Score based on trigger words
      Object.entries(intentPatterns).forEach(([intent, pattern]) => {
        pattern.triggers.forEach(trigger => {
          if (text.includes(trigger)) {
            scores[intent] += 3;
            // Boost score if trigger appears early in sentence
            const position = text.indexOf(trigger);
            if (position < text.length * 0.3) scores[intent] += 1;
          }
        });
        
        // Score based on contextual words
        pattern.contextual.forEach(context => {
          if (text.includes(context)) scores[intent] += 1;
        });
        
        // Penalize based on negative context
        pattern.negativeContext.forEach(negative => {
          if (text.includes(negative)) scores[intent] -= 2;
        });
      });
      
      // Contextual analysis based on conversation history
      const recentContext = conversationHistory.slice(-3);
      recentContext.forEach(entry => {
        if (entry.sender === 'bot') {
          const botText = entry.text.toLowerCase();
          if (botText.includes('when') && text.includes('also')) scores.when += 1;
          if (botText.includes('who') && text.includes('what about')) scores.who += 1;
          if (botText.includes('where') && text.includes('and')) scores.where += 1;
        }
      });
      
      // Grammar-based intent detection
      if (text.startsWith('when ') || text.includes(' when ')) scores.when += 2;
      if (text.startsWith('who ') || text.includes(' who ')) scores.who += 2;
      if (text.startsWith('where ') || text.includes(' where ')) scores.where += 2;
      if (text.startsWith('how ') || text.includes(' how ')) scores.how += 2;
      if (text.startsWith('why ') || text.includes(' why ')) scores.why += 2;
      if (text.startsWith('what is ') || text.startsWith('what are ')) scores.definition += 2;
      
      // Question mark analysis
      if (text.endsWith('?')) {
        const questionWords = ['when', 'who', 'where', 'how', 'why', 'what'];
        questionWords.forEach(qw => {
          if (text.includes(qw)) scores[qw === 'what' ? 'definition' : qw] += 1;
        });
      }
      
      // Find highest scoring intent
      let maxScore = 0;
      let detectedIntent = 'definition'; // default fallback
      
      Object.entries(scores).forEach(([intent, score]) => {
        if (score > maxScore) {
          maxScore = score;
          detectedIntent = intent;
        }
      });
      
      // If no clear winner, use sophisticated fallback logic
      if (maxScore < 2) {
        if (text.includes('is') || text.includes('are') || text.includes('means')) {
          return 'definition';
        }
        if (text.includes('happen') || text.includes('occur')) {
          return 'when';
        }
        if (text.includes('live') || text.includes('come from')) {
          return 'where';
        }
      }
      
      return detectedIntent;
    }

    // Enhanced topic extraction with better AI logic
    function extractSmartTopic(input) {
      const original = input.trim();
      const lower = original.toLowerCase().replace(/[?.,!]/g, '');
      
      // Smart name detection and correction
      const nameCorrections = {
        'einsten': 'einstein',
        'einstien': 'einstein',
        'darwin': 'charles darwin',
        'newton': 'isaac newton',
        'tesla': 'nikola tesla',
        'edison': 'thomas edison',
        'shakespeare': 'william shakespeare',
        'lincoln': 'abraham lincoln',
        'washington': 'george washington'
      };
      
      // Intent-based topic extraction
      const intent = detectIntent(input);
      
      // For "when" questions about people
      if (intent === 'when' && (lower.includes('born') || lower.includes('birth') || lower.includes('die') || lower.includes('death'))) {
        // Extract the person's name
        let personName = lower.replace(/when|was|were|is|are|born|birth|die|died|death/g, '').trim();
        
        // Apply corrections
        if (nameCorrections[personName]) {
          personName = nameCorrections[personName];
        }
        
        return personName;
      }
      
      // For "who" questions
      if (intent === 'who') {
        let topic = lower.replace(/who|is|was|were|are/g, '').trim();
        if (nameCorrections[topic]) {
          topic = nameCorrections[topic];
        }
        return topic;
      }
      
      // Advanced stopwords removal
      const stopwords = [
        'what','is','are','was','were','who','do','does','did','explain','define','about',
        'tell','me','the','a','an','of','it','that','on','in','to','from','by','you',
        'this','these','those','they','them','their','there','here','when','where',
        'how','why','can','could','would','should','will','shall','may','might',
        'and','or','but','so','if','then','than','as','at','for','with','without',
        'born', 'birth', 'die', 'died', 'death'
      ];

      const words = lower.split(' ').filter(word => word.length > 1 && !stopwords.includes(word));
      
      // Apply name corrections to extracted words
      const correctedWords = words.map(word => nameCorrections[word] || word);
      
      // Prioritize important terms
      const importantWords = correctedWords.filter(word => {
        // Keep longer, more specific words
        if (word.length > 4) return true;
        // Keep known important short words
        const importantShorts = ['ai', 'dna', 'rna', 'cpu', 'gpu', 'usa', 'uk', 'un'];
        if (importantShorts.includes(word)) return true;
        
        return word.length > 2;
      });
      
      // If we have important words, use them; otherwise fall back to all filtered words
      const finalWords = importantWords.length > 0 ? importantWords : correctedWords;
      
      return finalWords.slice(0, 3).join(' ');
    }

    // Enhanced Wikipedia fetching with intent-aware responses
    async function fetchWikiWithIntent(input) {
      const topic = extractSmartTopic(input);
      const intent = detectIntent(input);
      
      if (!topic || topic.trim() === '') {
        return "I couldn't understand what you're asking about. Could you please be more specific?";
      }

      // Hard-coded knowledge base for common queries to avoid API issues
      const knowledgeBase = {
        'einstein': {
          born: 'Albert Einstein was born on March 14, 1879.',
          died: 'Albert Einstein died on April 18, 1955.',
          info: 'Albert Einstein was a German-born theoretical physicist who developed the theory of relativity.'
        },
        'albert einstein': {
          born: 'Albert Einstein was born on March 14, 1879.',
          died: 'Albert Einstein died on April 18, 1955.',
          info: 'Albert Einstein was a German-born theoretical physicist who developed the theory of relativity.'
        },
        'newton': {
          born: 'Isaac Newton was born on January 4, 1643.',
          died: 'Isaac Newton died on March 31, 1727.',
          info: 'Isaac Newton was an English mathematician, physicist, and astronomer who formulated the laws of motion and universal gravitation.'
        },
        'isaac newton': {
          born: 'Isaac Newton was born on January 4, 1643.',
          died: 'Isaac Newton died on March 31, 1727.',
          info: 'Isaac Newton was an English mathematician, physicist, and astronomer who formulated the laws of motion and universal gravitation.'
        },
        'darwin': {
          born: 'Charles Darwin was born on February 12, 1809.',
          died: 'Charles Darwin died on April 19, 1882.',
          info: 'Charles Darwin was an English naturalist who proposed the theory of evolution by natural selection.'
        },
        'charles darwin': {
          born: 'Charles Darwin was born on February 12, 1809.',
          died: 'Charles Darwin died on April 19, 1882.',
          info: 'Charles Darwin was an English naturalist who proposed the theory of evolution by natural selection.'
        }
      };

      // Check knowledge base first
      const lowerTopic = topic.toLowerCase();
      if (knowledgeBase[lowerTopic]) {
        const data = knowledgeBase[lowerTopic];
        if (intent === 'when') {
          if (input.toLowerCase().includes('born') || input.toLowerCase().includes('birth')) {
            return data.born;
          } else if (input.toLowerCase().includes('die') || input.toLowerCase().includes('death')) {
            return data.died;
          }
        }
        return data.info;
      }

      // Try Wikipedia API as fallback
      try {
        const encodedTopic = encodeURIComponent(topic.trim());
        const url = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodedTopic}`;
        
        const res = await fetch(url);
        if (res.ok) {
          const data = await res.json();
          const text = data.extract || "No summary available.";
          return processWikiResponse(text, intent, input, data.title || topic);
        }
      } catch (error) {
        // Continue to fallback response
      }

      // Fallback response
      return `I don't have specific information about "${topic}" right now. Try asking about well-known historical figures like Einstein, Newton, or Darwin.`;
    }

    // Separate function to process Wikipedia responses based on intent
    function processWikiResponse(text, intent, originalInput, title) {

        // Intent-specific response processing
        switch (intent) {
          case 'when': {
            // Enhanced date extraction for birth/death questions
            if (originalInput.toLowerCase().includes('born') || originalInput.toLowerCase().includes('birth')) {
              // Look for birth dates
              const birthPatterns = [
                /born.*?(\d{1,2}\s+\w+\s+\d{4})/i,
                /born.*?(\w+\s+\d{1,2},?\s+\d{4})/i,
                /born.*?(\d{4})/i,
                /\((\d{4})[-â€“]\d{4}\)/i,  // (1879-1955) format
                /\((\d{4})/i  // (1879 format
              ];
              
              for (const pattern of birthPatterns) {
                const match = text.match(pattern);
                if (match) {
                  return `${title} was born in ${match[1]}.`;
                }
              }
            }
            
            if (originalInput.toLowerCase().includes('die') || originalInput.toLowerCase().includes('death')) {
              // Look for death dates
              const deathPatterns = [
                /died.*?(\d{1,2}\s+\w+\s+\d{4})/i,
                /died.*?(\w+\s+\d{1,2},?\s+\d{4})/i,
                /died.*?(\d{4})/i,
                /\(\d{4}[-â€“](\d{4})\)/i  // (1879-1955) format
              ];
              
              for (const pattern of deathPatterns) {
                const match = text.match(pattern);
                if (match) {
                  return `${title} died in ${match[1]}.`;
                }
              }
            }
            
            // General date patterns
            const datePatterns = [
              /(?:in\s+)?(\d{1,2}(?:st|nd|rd|th)?\s+(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4})/gi,
              /(?:in\s+)?(\d{4})/g,
              /((?:early|mid|late)\s+\d{4}s?)/gi,
              /((?:19|20)\d{2}[-â€“]\d{2,4})/g
            ];
            
            for (const pattern of datePatterns) {
              const matches = text.match(pattern);
              if (matches) {
                return `Based on the information available, this occurred in ${matches[0].replace(/^in\s+/i, '')}.`;
              }
            }
            
            return `Here's what I found about ${title}: ${text.substring(0, 200)}...`;
          }

          case 'who': {
            // Extract person names and roles
            const personPattern = /^([A-Z][a-z]+(?:\s+[A-Z][a-z]+)+)(?:\s+\([\dâ€“]+\))?\s+(?:was|is)\s+(.+?)(?:\.|,)/;
            const match = text.match(personPattern);
            if (match) {
              return `${match[1]} was ${match[2]}.`;
            }
            
            // Look for leadership or role information
            const rolePattern = /(president|king|queen|emperor|leader|founder|creator|inventor|author|scientist|artist).*?([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)/i;
            const roleMatch = text.match(rolePattern);
            if (roleMatch) {
              return `The ${roleMatch[1]} was ${roleMatch[2]}.`;
            }
            
            return text.substring(0, 150) + '...';
          }

          case 'where': {
            // Extract location information
            const locationPatterns = [
              /(?:located|situated|found|based)\s+in\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)/i,
              /in\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*),?\s+([A-Z][a-z]+)/i,
              /([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\s+is\s+(?:a|an)\s+.*?(?:in|of)\s+([A-Z][a-z]+)/i
            ];
            
            for (const pattern of locationPatterns) {
              const match = text.match(pattern);
              if (match) {
                return `It is located in ${match[1]}${match[2] ? ', ' + match[2] : ''}.`;
              }
            }
            
            return text.substring(0, 150) + '...';
          }

          case 'how': {
            // Look for process, mechanism, or method descriptions
            const processWords = ['process', 'method', 'mechanism', 'procedure', 'technique', 'way', 'manner'];
            const sentences = text.split(/[.!?]+/);
            
            for (const sentence of sentences) {
              if (processWords.some(word => sentence.toLowerCase().includes(word))) {
                return sentence.trim() + '.';
              }
            }
            
            return text.substring(0, 200) + '...';
          }

          case 'why': {
            // Look for explanations, reasons, purposes
            const reasonWords = ['because', 'due to', 'reason', 'purpose', 'goal', 'aim', 'intended'];
            const sentences = text.split(/[.!?]+/);
            
            for (const sentence of sentences) {
              if (reasonWords.some(word => sentence.toLowerCase().includes(word))) {
                return sentence.trim() + '.';
              }
            }
            
            return text.substring(0, 200) + '...';
          }

          case 'comparison': {
            // Handle comparison requests
            return `Here's information about ${title}: ${text.substring(0, 180)}...`;
          }

          default: // definition
            return text.substring(0, 250) + (text.length > 250 ? '...' : '');
        }
      } catch (error) {
        return `I encountered an error while searching for information about "${topic}". Please try rephrasing your question.`;
      }
    }

    async function getResponse(text) {
      const originalText = text;
      text = text.toLowerCase();

      // Handle context
      if (currentContext) {
        for (const category in loadedData) {
          const data = loadedData[category];
          for (const entry of data) {
            if (entry.required_context === currentContext && entry.keywords) {
              if (entry.keywords.includes(text)) {
                currentContext = null;
                return entry.output;
              }
            }
          }
        }
        return "I was waiting for a 'yes' or 'no' answer.";
      }

      // Load JSONs
      const categoriesToLoad = Object.keys(dataFiles);
      await Promise.all(categoriesToLoad.map(cat => loadData(cat)));

      // Check against JSON with enhanced matching
      for (const category of categoriesToLoad) {
        const data = loadedData[category];
        for (const entry of data) {
          if (entry.__comment) continue;
          if (entry.keywords && matchKeywords(entry.keywords, text)) {
            if (entry.expecting) currentContext = entry.id;
            if (entry.output.startsWith("wiki:")) {
              const topic = entry.output.replace("wiki:", "").trim();
              return await fetchWikiWithIntent(`${topic} ${originalText}`);
            }
            return entry.output;
          }
        }
      }

      // Fallback to enhanced AI-powered wiki fetch
      return await fetchWikiWithIntent(originalText);
    }

    async function sendMessage() {
      const text = input.value.trim();
      if (!text) return;
      appendMessage('user', text);
      input.value = '';
      const botReply = await getResponse(text);
      appendMessage('bot', botReply);
    }

    input.addEventListener('keydown', e => {
      if (e.key === 'Enter') sendMessage();
    });
  </script>
</body>
</html>
